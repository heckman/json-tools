#!/usr/bin/env zsh
# Copyright 2024 Erik Ben Heckman <erik@heckman.ca>
# SPDX-License-Identifier: MIT


# json-env v0.4


# generate json from environment vars

# usage: json-env [OPTIONS] [pattern] ...
#
# Writes environment variables to stdout as a json object.
#
# If pattern is specified, only variables it matches entirely will be included.
# (I.e. the expression is wrapped in ^$ to match the entire variable name.)
#
# OPTIONS:
#   -k or --key will wrap the variables in an object with the specified name.
#   -w and --wrap are shortcuts for --key env
#
#
# Pattern is a "Perl with Named Groups" regular expression.
# See: https://jqlang.github.io/jq/manual/#regular-expressions
#
#
# Requires `jq` which does the heavy lifting
#

help() { >&2 awk '/^ *[^#]/{exit}NR>1{print substr($0,2)}' $ZSH_ARGZERO; }
version() { >&2 awk '$0~'"${(qqq)ZSH_ARGZERO:A:t}"'{print substr($0,2);exit}' $ZSH_ARGZERO; }

opts=(-n)
while [[ ${1:-} = -* ]]
do case ${1:-} in
	-h|--help|) help; exit ;;
	-v|--version) version; exit ;;
	-w|--wrap) opts+=(--arg key "env"); shift ;;
	-k|--key)
		shift
		opts+=(--arg key $1)
		shift 2>/dev/null || {
			echo 'Error: missing key. Use -h or --help for usage.'>&2
			exit 1
		} ;;
	--) shift; break ;;
	-*) break ;; # unrecognized options assumed to be positional arguments
esac
done

jq "${opts[@]}" '
	if ($ARGS.positional|length>0) then
		( $ARGS.positional | join("|") | "^("+.+")$" ) as $pattern
		| env | with_entries (
			select( .key | test($pattern) )
		)
	else
		env
	end
	|
	if $ARGS.named.key? then . as $item | { ($ARGS.named.key): $item }
	else .
	end
' --args "$@"
