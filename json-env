#!/usr/bin/env zsh
# Copyright 2024 Erik Ben Heckman <erik@heckman.ca>
# SPDX-License-Identifier: MIT


# json-env v0.4


# generate json from environment vars

# usage: json-env [-w|--wrap|-k <name>|--key <name>] [pattern]
#
# Writes environment variables to stdout as a json object.
# If pattern is specified, only variables matching it will be included.
#
# -k or --key will wrap the variables in an object with the specified name.
#
# -w and --wrap are shortcuts for --key env
#
# Pattern is a "Perl with Named Groups" regular expression.
# See: https://jqlang.github.io/jq/manual/#regular-expressions
#
#
# Requires `jq` which does the heavy lifting
#

help() { >&2 awk '/^ *[^#]/{exit}NR>1{print substr($0,2)}' $ZSH_ARGZERO; }
version() { >&2 awk '$0~'"${(qqq)ZSH_ARGZERO:A:t}"'{print substr($0,2);exit}' $ZSH_ARGZERO; }

while [[ ${1:-} = -* ]]
do case ${1:-} in
	-h|--help|) help; exit ;;
	-v|--version) version; exit ;;
	-w|--wrap) opts=(--arg key "env"); shift ;;
	-k|--key)
		shift
		opts=(--arg key $1)
		shift 2>/dev/null || {
			echo 'Error: missing key. Use -h or --help for usage.'>&2
			exit 1
		} ;;
	--) shift; break ;;
	-*) break ;; # unrecognized options assumed to be positional arguments
esac
done
opts+=(--arg pattern "$*")

jq -n "${opts[@]}" '
	env |
	with_entries (
		select( .key | test($pattern) )
	) | if $ARGS.named.key? then . as $item | { ($ARGS.named.key): $item } else . end
'
